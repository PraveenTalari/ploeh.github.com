---
layout: post
title: "Das verflixte Hunde-Spiel"
description: "A puzzle kata, and a possible solution."
date: 2024-10-03 17:41 UTC
tags: [Haskell]
image: "/content/binary/hunde-spiel.jpg"
image_alt: "A picture of the box of the puzzle, together with the tiles spread out in unordered fashion."
---
{% include JB/setup %}

<div id="post">
    <p>
        <em>{{ page.description }}</em>
    </p>
    <p>
        When I was a boy I had a nine-piece puzzle that I'd been gifted by the Swizz branch of my family. It's called <em>Das verflixte Hunde-Spiel</em>, which means something like <em>the confounded dog game</em> in English. And while a puzzle with nine pieces doesn't sound like much, it is, in fact, incredibly difficult.
    </p>
    <p>
        It's just a specific incarnation of a kind of game that you've almost certainly encountered, too.
    </p>
    <p>
        <img src="/content/binary/hunde-spiel.jpg" alt="A picture of the box of the puzzle, together with the tiles spread out in unordered fashion.">
    </p>
    <p>
        There are nine tiles, each with two dog heads and two dog ends. A dog may be coloured in one of four different patterns. The object of the game is to lay out the nine tiles in a 3x3 square so that all dog halves line up.
    </p>
    <h3 id="ddf5aa390eed4147a55a35e95803b6ad">
        Game details <a href="#ddf5aa390eed4147a55a35e95803b6ad">#</a>
    </h3>
    <p>
        The game is from 1979. Two of the tiles are identical, and, according to the information on the back of the box, two possible solutions exist. Described from top clockwise, the tiles are the following:
    </p>
    <ul>
        <li>Brown head, grey head, umber tail, spotted tail</li>
        <li>Brown head, spotted head, brown tail, umber tail</li>
        <li>Brown head, spotted head, grey tail, umber tail</li>
        <li>Brown head, spotted head, grey tail, umber tail</li>
        <li>Brown head, umber head, spotted tail, grey tail</li>
        <li>Grey head, brown head, spotted tail, umber tail</li>
        <li>Grey head, spotted head, brown tail, umber tail</li>
        <li>Grey head, umber head, brown tail, spotted tail</li>
        <li>Grey head, umber head, grey tail, spotted tail</li>
    </ul>
    <p>
        I've taken the liberty of using a shorthand for the patterns. The grey dogs are actually also spotted, but since there's only one grey pattern, the <em>grey</em> label is unambiguous. The dogs I've named <em>umber</em> are actually rather <em>burnt umber</em>, but that's too verbose for my tastes, so I just named them <em>umber</em>. Finally, the label <em>spotted</em> indicates dogs that are actually burnt umber with brown blotches.
    </p>
    <p>
        Notice that there are two tiles with a brown head, a spotted head, a grey tail, and an umber tail.
    </p>
    <p>
        The object of the game is to lay down the tiles in a 3x3 square so that all dogs fit. For further reference, I've numbered each position from one to nine like this:
    </p>
    <p>
        <img src="/content/binary/numbered-3x3-tiles.png" alt="Nine tiles arranged in a three-by-three square, numbered from 1 to 9 from top left to bottom right.">
    </p>
    <p>
        What makes the game hard? There are nine cards, so if you start with the upper left corner, you have nine choices. If you just randomly put down the tiles, you now have eight left for the top middle position, and so on. Standard combinatorics indicate that there are at least 9! = 362,880 permutations.
    </p>
    <p>
        That's not the whole story, however, since you can rotate each tile in four different ways. You can rotate the first tile four ways, the second tile four ways, etc. for a total of 4<sup>9</sup> = 262,144 ways. Multiply these two numbers together, and you get 4<sup>9</sup>9! = 95,126,814,720 combinations. No wonder this puzzle is hard if there's only two solutions.
    </p>
    <p>
        When analysed this way, however, there are actually 16 solutions, but that still makes it incredibly unlikely to arrive at a solution by chance. I'll get back to why there are 16 solutions later. For now, you should have enough information to try your hand with this game, if you'd like.
    </p>
    <p>
        I found that the game made for an interesting <a href="/2020/01/13/on-doing-katas">kata</a>: Write a program that finds all possible solutions to the puzzle.
    </p>
    <p>
        If you'd like to try your hand at this exercise, I suggest that you pause reading here.
    </p>
    <p>
        In the rest of the article, I'll outline my first attempt. Spoiler alert: I'll also show one of the solutions.
    </p>
    <h3 id="113acd886fde4791b10c4a2b6f394216">
        Types <a href="#113acd886fde4791b10c4a2b6f394216">#</a>
    </h3>
    <p>
        When you program in <a href="https://www.haskell.org/">Haskell</a>, it's natural to start by defining some types.
    </p>
    <p>
        <pre><span style="color:blue;">data</span>&nbsp;Half&nbsp;=&nbsp;Head&nbsp;|&nbsp;Tail&nbsp;<span style="color:blue;">deriving</span>&nbsp;(<span style="color:#2b91af;">Show</span>,&nbsp;<span style="color:#2b91af;">Eq</span>)

<span style="color:blue;">data</span>&nbsp;Pattern&nbsp;=&nbsp;Brown&nbsp;|&nbsp;Grey&nbsp;|&nbsp;Spotted&nbsp;|&nbsp;Umber&nbsp;<span style="color:blue;">deriving</span>&nbsp;(<span style="color:#2b91af;">Show</span>,&nbsp;<span style="color:#2b91af;">Eq</span>)

<span style="color:blue;">data</span>&nbsp;Tile&nbsp;=&nbsp;Tile&nbsp;{
&nbsp;&nbsp;<span style="color:#2b91af;">top</span>&nbsp;<span style="color:blue;">::</span>&nbsp;(<span style="color:blue;">Pattern</span>,&nbsp;<span style="color:blue;">Half</span>),
&nbsp;&nbsp;<span style="color:#2b91af;">right</span>&nbsp;<span style="color:blue;">::</span>&nbsp;(<span style="color:blue;">Pattern</span>,&nbsp;<span style="color:blue;">Half</span>),
&nbsp;&nbsp;<span style="color:#2b91af;">bottom</span>&nbsp;<span style="color:blue;">::</span>&nbsp;(<span style="color:blue;">Pattern</span>,&nbsp;<span style="color:blue;">Half</span>),
&nbsp;&nbsp;<span style="color:#2b91af;">left</span>&nbsp;<span style="color:blue;">::</span>&nbsp;(<span style="color:blue;">Pattern</span>,&nbsp;<span style="color:blue;">Half</span>)&nbsp;}
&nbsp;&nbsp;<span style="color:blue;">deriving</span>&nbsp;(<span style="color:#2b91af;">Show</span>,&nbsp;<span style="color:#2b91af;">Eq</span>)</pre>
    </p>
    <p>
        Each tile describes what you find on its <code>top</code>, <code>right</code> side, <code>bottom</code>, and <code>left</code> side.
    </p>
    <p>
        We're also going to need a function to evaluate whether two halves match:
    </p>
    <p>
        <pre><span style="color:#2b91af;">matches</span>&nbsp;<span style="color:blue;">::</span>&nbsp;(<span style="color:blue;">Pattern</span>,&nbsp;<span style="color:blue;">Half</span>)&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;(<span style="color:blue;">Pattern</span>,&nbsp;<span style="color:blue;">Half</span>)&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:#2b91af;">Bool</span>
matches&nbsp;(p1,&nbsp;h1)&nbsp;(p2,&nbsp;h2)&nbsp;=&nbsp;p1&nbsp;==&nbsp;p2&nbsp;&amp;&amp;&nbsp;h1&nbsp;/=&nbsp;h2</pre>
    </p>
    <p>
        This function demands that the patterns match, but that the halves are opposites.
    </p>
    <p>
        You can use the <code>Tile</code> type and its constituents to define the nine tiles of the game:
    </p>
    <p>
        <pre><span style="color:#2b91af;">tiles</span>&nbsp;<span style="color:blue;">::</span>&nbsp;[<span style="color:blue;">Tile</span>]
tiles&nbsp;=
&nbsp;&nbsp;[
&nbsp;&nbsp;&nbsp;&nbsp;Tile&nbsp;(Brown,&nbsp;Head)&nbsp;(Grey,&nbsp;Head)&nbsp;(Umber,&nbsp;Tail)&nbsp;(Spotted,&nbsp;Tail),
&nbsp;&nbsp;&nbsp;&nbsp;Tile&nbsp;(Brown,&nbsp;Head)&nbsp;(Spotted,&nbsp;Head)&nbsp;(Brown,&nbsp;Tail)&nbsp;(Umber,&nbsp;Tail),
&nbsp;&nbsp;&nbsp;&nbsp;Tile&nbsp;(Brown,&nbsp;Head)&nbsp;(Spotted,&nbsp;Head)&nbsp;(Grey,&nbsp;Tail)&nbsp;(Umber,&nbsp;Tail),
&nbsp;&nbsp;&nbsp;&nbsp;Tile&nbsp;(Brown,&nbsp;Head)&nbsp;(Spotted,&nbsp;Head)&nbsp;(Grey,&nbsp;Tail)&nbsp;(Umber,&nbsp;Tail),
&nbsp;&nbsp;&nbsp;&nbsp;Tile&nbsp;(Brown,&nbsp;Head)&nbsp;(Umber,&nbsp;Head)&nbsp;(Spotted,&nbsp;Tail)&nbsp;(Grey,&nbsp;Tail),
&nbsp;&nbsp;&nbsp;&nbsp;Tile&nbsp;(Grey,&nbsp;Head)&nbsp;(Brown,&nbsp;Head)&nbsp;(Spotted,&nbsp;Tail)&nbsp;(Umber,&nbsp;Tail),
&nbsp;&nbsp;&nbsp;&nbsp;Tile&nbsp;(Grey,&nbsp;Head)&nbsp;(Spotted,&nbsp;Head)&nbsp;(Brown,&nbsp;Tail)&nbsp;(Umber,&nbsp;Tail),
&nbsp;&nbsp;&nbsp;&nbsp;Tile&nbsp;(Grey,&nbsp;Head)&nbsp;(Umber,&nbsp;Head)&nbsp;(Brown,&nbsp;Tail)&nbsp;(Spotted,&nbsp;Tail),
&nbsp;&nbsp;&nbsp;&nbsp;Tile&nbsp;(Grey,&nbsp;Head)&nbsp;(Umber,&nbsp;Head)&nbsp;(Grey,&nbsp;Tail)&nbsp;(Spotted,&nbsp;Tail)
&nbsp;&nbsp;]</pre>
    </p>
    <p>
        Because I'm the neatnik that I am, I've sorted the tiles in lexicographic order, but the solution below doesn't rely on that.
    </p>
    <h3 id="1568796e41484e21bae6bb5734f996eb">
        Brute force doesn't work <a href="#1568796e41484e21bae6bb5734f996eb">#</a>
    </h3>
    <p>
        Before I started, I cast around the internet to see if there was an appropriate algorithm for the problem. While I found a few answers on <a href="https://stackoverflow.com/">Stack Overflow</a>, none of them gave me indication that any sophisticated algorithm was available. (Even so, there may be, and I just didn't find it.)
    </p>
    <p>
        It seems clear, however, that you can implement some kind of recursive search-tree algorithm that cuts a branch off as soon as it realizes that it doesn't work. I'll get back to that later, so let's leave that for now.
    </p>
    <p>
        Since I'd planned on writing the code in Haskell, I decided to first try something that might look like brute force. Because Haskell is lazily evaluated, you can sometimes get away with techniques that look wasteful when you're used to strict/eager evaluation. In this case, it turned out to not work, but it's often quicker to just make the attempt than trying to analyze the problem.
    </p>
    <p>
        As already outlined, I first attempted a purely brute-force solution, betting that Haskell's lazy evaluation would be enough to skip over the unnecessary calculations:
    </p>
    <p>
        <pre>allRotationsOf9&nbsp;=&nbsp;replicateM&nbsp;9&nbsp;[0..3]

<span style="color:#2b91af;">allRotations</span>&nbsp;<span style="color:blue;">::</span>&nbsp;[<span style="color:blue;">Tile</span>]&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;[[<span style="color:blue;">Tile</span>]]
allRotations&nbsp;ts&nbsp;=&nbsp;<span style="color:blue;">fmap</span>&nbsp;(\rs&nbsp;-&gt;&nbsp;(\(r,&nbsp;t)&nbsp;-&gt;&nbsp;rotations&nbsp;t&nbsp;!!&nbsp;r)&nbsp;&lt;$&gt;&nbsp;<span style="color:blue;">zip</span>&nbsp;rs&nbsp;ts)&nbsp;allRotationsOf9

<span style="color:#2b91af;">allConfigurations</span>&nbsp;<span style="color:blue;">::</span>&nbsp;[[<span style="color:blue;">Tile</span>]]
allConfigurations&nbsp;=&nbsp;permutations&nbsp;tiles&nbsp;&gt;&gt;=&nbsp;allRotations

solutions&nbsp;=&nbsp;<span style="color:blue;">filter</span>&nbsp;isSolution&nbsp;allConfigurations</pre>
    </p>
    <p>
        My idea with the <code>allConfigurations</code> value was that it's supposed to enumerate all 95 billion combinations. Whether it actually does that, I was never able to verify, because if I try to run that code, my poor laptop runs for a couple of hours before it eventually runs out of memory. In other words, the GHCi process crashes.
    </p>
    <p>
        I haven't shown <code>isSolution</code> or <code>rotations</code>, because I consider the implementations irrelevant. This attempt doesn't work anyway.
    </p>
    <p>
        Now that I look at it, it's quite clear why this isn't a good strategy. There's little to be gained from lazy evaluation when the final attempt just attempts to <code>filter</code> a list. Even with lazy evaluation, the code still has to run through all 95 billion combinations.
    </p>
    <p>
        Things might have been different if I just had to find one solution. With a little luck, it might be that the first solution appears after, say, a hundred million iterations, and lazy evaluation would then had meant that the remaining combinations would never run. Not so here, but hindsight is 20-20.
    </p>
    <h3 id="93754ac1a84e4a42b87253f1ffded97b">
        Search tree <a href="#93754ac1a84e4a42b87253f1ffded97b">#</a>
    </h3>
    <p>
        Back to the search tree idea. It goes like this: Start from the top left position and pick a random tile and rotation. Now pick an arbitrary tile <em>that fits</em> and place it to the right of it, and so on. As far as I can tell, you can always place the first four cards, but from there, you can easily encounter a combination that allows no further tiles. Here's an example:
    </p>
    <p>
        <img src="/content/binary/hunde-spiel-no-fifth-tile.jpg" alt="Four matching tiles put down, with the remaining five tiles arranged to show that none of them fit the fifth position.">
    </p>
    <p>
        None of the remaining five tiles fit in the fifth position. This means that we don't have to do <em>any</em> permutations that involve these four tiles in that combination. While the algorithm has to search through all five remaining tiles and rotations to discover that none fit in position 5, once it knows that, it doesn't have to go through the remaining four positions. That's 4<sup>4</sup>4! = 6,144 combinations that it can skip every time it discovers an impossible beginning. That doesn't sound like that much, but if we assume that this happens more often than not, it's still an improvement by orders of magnitude.
    </p>
    <p>
        We may think of this algorithm as constructing a search tree, but immediately pruning all branches that aren't viable, as close to the root as possible.
    </p>
    <h3 id="76d4e7e1898a4da89de0d7afabbdc4e8">
        Matches <a href="#76d4e7e1898a4da89de0d7afabbdc4e8">#</a>
    </h3>
    <p>
        Before we get to the algorithm proper we need a few simple helper functions. One kind of function is a predicate that determines if a particular tile can occupy a given position. Since we may place any tile in any rotation in the first position, we don't need to write a predicate for that, but if we wanted to generalize, <code>const True</code> would do.
    </p>
    <p>
        Whether or not we can place a given tile in the second position depends exclusively on the tile in the first position:
    </p>
    <p>
        <pre><span style="color:#2b91af;">tile2Matches</span>&nbsp;<span style="color:blue;">::</span>&nbsp;<span style="color:blue;">Tile</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:blue;">Tile</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:#2b91af;">Bool</span>
tile2Matches&nbsp;t1&nbsp;t2&nbsp;=&nbsp;right&nbsp;t1&nbsp;`matches`&nbsp;left&nbsp;t2</pre>
    </p>
    <p>
        If the <code>right</code> dog part of the first tile <code>matches</code> the <code>left</code> part of the second tile, the return value is <code>True</code>; otherwise, it's <code>False</code>. Note that I'm using infix notation for <code>matches</code>. I could also have written the function as
    </p>
    <p>
        <pre><span style="color:#2b91af;">tile2Matches</span>&nbsp;<span style="color:blue;">::</span>&nbsp;<span style="color:blue;">Tile</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:blue;">Tile</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:#2b91af;">Bool</span>
tile2Matches&nbsp;t1&nbsp;t2&nbsp;=&nbsp;matches&nbsp;(right&nbsp;t1)&nbsp;(left&nbsp;t2)</pre>
    </p>
    <p>
        but it doesn't read as well.
    </p>
    <p>
        In any case, the corresponding matching functions for the third and forth tile look similar:
    </p>
    <p>
        <pre><span style="color:#2b91af;">tile3Matches</span>&nbsp;<span style="color:blue;">::</span>&nbsp;<span style="color:blue;">Tile</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:blue;">Tile</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:#2b91af;">Bool</span>
tile3Matches&nbsp;t2&nbsp;t3&nbsp;=&nbsp;right&nbsp;t2&nbsp;`matches`&nbsp;left&nbsp;t3

<span style="color:#2b91af;">tile4Matches</span>&nbsp;<span style="color:blue;">::</span>&nbsp;<span style="color:blue;">Tile</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:blue;">Tile</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:#2b91af;">Bool</span>
tile4Matches&nbsp;t1&nbsp;t4&nbsp;=&nbsp;bottom&nbsp;t1&nbsp;`matches`&nbsp;top&nbsp;t4</pre>
    </p>
    <p>
        Notice that <code>tile4Matches</code> compares the fourth tile with the first tile rather than the third tile, because position 4 is directly beneath position 1, rather than to the right of position 3 (cf. the grid above). For that reason it also compares the <code>bottom</code> of tile 1 to the <code>top</code> of the fourth tile.
    </p>
    <p>
        The matcher for the fifth tile is different:
    </p>
    <p>
        <pre><span style="color:#2b91af;">tile5Matches</span>&nbsp;<span style="color:blue;">::</span>&nbsp;<span style="color:blue;">Tile</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:blue;">Tile</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:blue;">Tile</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:#2b91af;">Bool</span>
tile5Matches&nbsp;t2&nbsp;t4&nbsp;t5&nbsp;=&nbsp;bottom&nbsp;t2&nbsp;`matches`&nbsp;top&nbsp;t5&nbsp;&amp;&amp;&nbsp;right&nbsp;t4&nbsp;`matches`&nbsp;left&nbsp;t5</pre>
    </p>
    <p>
        This is the first predicate that depends on two, rather than one, previous tiles. In position 5 we need to examine both the tile in position 2 and the one in position 4.
    </p>
    <p>
        The same is true for position 6:
    </p>
    <p>
        <pre><span style="color:#2b91af;">tile6Matches</span>&nbsp;<span style="color:blue;">::</span>&nbsp;<span style="color:blue;">Tile</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:blue;">Tile</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:blue;">Tile</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:#2b91af;">Bool</span>
tile6Matches&nbsp;t3&nbsp;t5&nbsp;t6&nbsp;=&nbsp;bottom&nbsp;t3&nbsp;`matches`&nbsp;top&nbsp;t6&nbsp;&amp;&amp;&nbsp;right&nbsp;t5&nbsp;`matches`&nbsp;left&nbsp;t6</pre>
    </p>
    <p>
        but then the matcher for position 7 looks like the predicate for position 4:
    </p>
    <p>
        <pre><span style="color:#2b91af;">tile7Matches</span>&nbsp;<span style="color:blue;">::</span>&nbsp;<span style="color:blue;">Tile</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:blue;">Tile</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:#2b91af;">Bool</span>
tile7Matches&nbsp;t4&nbsp;t7&nbsp;=&nbsp;bottom&nbsp;t4&nbsp;`matches`&nbsp;top&nbsp;t7</pre>
    </p>
    <p>
        This is, of course, because the tile in position 7 only has to consider the tile in position 4. Finally, not surprising, the two remaining predicates look like something we've already seen:
    </p>
    <p>
        <pre><span style="color:#2b91af;">tile8Matches</span>&nbsp;<span style="color:blue;">::</span>&nbsp;<span style="color:blue;">Tile</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:blue;">Tile</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:blue;">Tile</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:#2b91af;">Bool</span>
tile8Matches&nbsp;t5&nbsp;t7&nbsp;t8&nbsp;=&nbsp;bottom&nbsp;t5&nbsp;`matches`&nbsp;top&nbsp;t8&nbsp;&amp;&amp;&nbsp;right&nbsp;t7&nbsp;`matches`&nbsp;left&nbsp;t8

<span style="color:#2b91af;">tile9Matches</span>&nbsp;<span style="color:blue;">::</span>&nbsp;<span style="color:blue;">Tile</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:blue;">Tile</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:blue;">Tile</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:#2b91af;">Bool</span>
tile9Matches&nbsp;t6&nbsp;t8&nbsp;t9&nbsp;=&nbsp;bottom&nbsp;t6&nbsp;`matches`&nbsp;top&nbsp;t9&nbsp;&amp;&amp;&nbsp;right&nbsp;t8&nbsp;`matches`&nbsp;left&nbsp;t9</pre>
    </p>
    <p>
        You may suggest that it'd be possible to reduce the number of predicates. After all, there's effectively only three different predicates: One that only looks at the tile to the left, one that only looks at the tile above, and one that looks both to the left and above.
    </p>
    <p>
        Indeed, I could have boiled it down to just three functions:
    </p>
    <p>
        <pre><span style="color:#2b91af;">matchesHorizontally</span>&nbsp;<span style="color:blue;">::</span>&nbsp;<span style="color:blue;">Tile</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:blue;">Tile</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:#2b91af;">Bool</span>
matchesHorizontally&nbsp;x&nbsp;y&nbsp;=&nbsp;right&nbsp;x&nbsp;`matches`&nbsp;left&nbsp;y

<span style="color:#2b91af;">matchesVertically</span>&nbsp;<span style="color:blue;">::</span>&nbsp;<span style="color:blue;">Tile</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:blue;">Tile</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:#2b91af;">Bool</span>
matchesVertically&nbsp;x&nbsp;y&nbsp;=&nbsp;bottom&nbsp;x&nbsp;`matches`&nbsp;top&nbsp;y

<span style="color:#2b91af;">matchesBoth</span>&nbsp;<span style="color:blue;">::</span>&nbsp;<span style="color:blue;">Tile</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:blue;">Tile</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:blue;">Tile</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:#2b91af;">Bool</span>
matchesBoth&nbsp;x&nbsp;y&nbsp;z&nbsp;=&nbsp;matchesVertically&nbsp;x&nbsp;z&nbsp;&amp;&amp;&nbsp;matchesHorizontally&nbsp;y&nbsp;z</pre>
    </p>
    <p>
        but I now run the risk of calling the wrong predicate from my implementation of the algorithm. As you'll see, I'll call each predicate by name at each appropriate step, but if I had only these three functions, there's a risk that I might mistakenly use <code>matchesHorizontally</code> when I should have used <code>matchesVertically</code>, or vice versa. Reducing eight one-liners to three one-liners doesn't really seem to warrant the risk.
    </p>
    <h3 id="01bf66f9df1947d296a004e93638450d">
        Rotations <a href="#01bf66f9df1947d296a004e93638450d">#</a>
    </h3>
    <p>
        In addition to examining whether a given tile fits in a given position, we also need to be able to rotate any tile:
    </p>
    <p>
        <pre><span style="color:#2b91af;">rotateClockwise</span>&nbsp;<span style="color:blue;">::</span>&nbsp;<span style="color:blue;">Tile</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:blue;">Tile</span>
rotateClockwise&nbsp;(Tile&nbsp;t&nbsp;r&nbsp;b&nbsp;l)&nbsp;=&nbsp;Tile&nbsp;l&nbsp;t&nbsp;r&nbsp;b

<span style="color:#2b91af;">rotateCounterClockwise</span>&nbsp;<span style="color:blue;">::</span>&nbsp;<span style="color:blue;">Tile</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:blue;">Tile</span>
rotateCounterClockwise&nbsp;(Tile&nbsp;t&nbsp;r&nbsp;b&nbsp;l)&nbsp;=&nbsp;Tile&nbsp;r&nbsp;b&nbsp;l&nbsp;t

<span style="color:#2b91af;">upend</span>&nbsp;<span style="color:blue;">::</span>&nbsp;<span style="color:blue;">Tile</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;<span style="color:blue;">Tile</span>
upend&nbsp;(Tile&nbsp;t&nbsp;r&nbsp;b&nbsp;l)&nbsp;=&nbsp;Tile&nbsp;b&nbsp;l&nbsp;t&nbsp;r</pre>
    </p>
    <p>
        What is really needed, it turns out, is to enumerate all four rotations of a tile:
    </p>
    <p>
        <pre><span style="color:#2b91af;">rotations</span>&nbsp;<span style="color:blue;">::</span>&nbsp;<span style="color:blue;">Tile</span>&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;[<span style="color:blue;">Tile</span>]
rotations&nbsp;t&nbsp;=&nbsp;[t,&nbsp;rotateClockwise&nbsp;t,&nbsp;upend&nbsp;t,&nbsp;rotateCounterClockwise&nbsp;t]</pre>
    </p>
    <p>
        Since this, like everything else here, is a pure function, I experimented with defining a 'memoized tile' type that embedded all four rotations upon creation, so that the algorithm doesn't need to call the <code>rotations</code> function millions of times, but I couldn't measure any discernable performance improvement from it. There's no reason to make things more complicated than they need to be, so I didn't keep that change. (Since I do, however, <a href="https://stackoverflow.blog/2022/12/19/use-git-tactically/">use Git tactically</a> i did, of course, <a href="https://git-scm.com/docs/git-stash">stash</a> the experiment.)
    </p>
    <h3 id="8e7ce1c1bb9c4403abd72d5d3d87bf02">
        Permutations <a href="#8e7ce1c1bb9c4403abd72d5d3d87bf02">#</a>
    </h3>
    <p>
        While I couldn't make things work by enumerating all 95 billion combinations, enumerating all 362,880 permutations of non-rotated tiles is well within the realm of the possible:
    </p>
    <p>
        <pre><span style="color:#2b91af;">allPermutations</span>&nbsp;<span style="color:blue;">::</span>&nbsp;[(<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>)]
allPermutations&nbsp;=
&nbsp;&nbsp;(\[t1,&nbsp;t2,&nbsp;t3,&nbsp;t4,&nbsp;t5,&nbsp;t6,&nbsp;t7,&nbsp;t8,&nbsp;t9]&nbsp;-&gt;&nbsp;(t1,&nbsp;t2,&nbsp;t3,&nbsp;t4,&nbsp;t5,&nbsp;t6,&nbsp;t7,&nbsp;t8,&nbsp;t9))
&nbsp;&nbsp;&lt;$&gt;&nbsp;permutations&nbsp;tiles</pre>
    </p>
    <p>
        Doing this in GHCi on my old laptop takes 300 milliseconds, which is good enough compared to what comes next.
    </p>
    <p>
        This list value uses <a href="https://hackage.haskell.org/package/base/docs/Data-List.html#v:permutations">permutations</a> to enumerate all the permutations. You may already have noticed that it converts the result into a nine-tuple. The reason for that is that this enables the algorithm to pattern-match into specific positions without having to resort to the <a href="https://hackage.haskell.org/package/base/docs/Data-List.html#v:-33--33-">index operator</a>, which is both partial and requires iteration of the list to reach the indexed element. Granted, the list is only nine elements long, and often the algorithm will only need to index to the fourth or fifth element. On the other hand, it's going to do it <em>a lot</em>. Perhaps it's a premature optimization, but if it is, it's at least one that makes the code more, rather than less, readable.
    </p>
    <h3 id="3f0af3d6c91a4cd68b026a0ccf93a0e2">
        Algorithm <a href="#3f0af3d6c91a4cd68b026a0ccf93a0e2">#</a>
    </h3>
    <p>
        I found it easiest to begin at the 'bottom' of what is effectively a recursive algorithm, even though I didn't implement it that way. At the 'bottom', I imagine that I'm almost done: That I've found eight tiles that match, and now I only need to examine if I can rotate the final tile so that it matches:
    </p>
    <p>
        <pre><span style="color:#2b91af;">solve9th</span>&nbsp;<span style="color:blue;">::</span>&nbsp;&nbsp;(a,&nbsp;b,&nbsp;c,&nbsp;d,&nbsp;e,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;g,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;[(a,&nbsp;b,&nbsp;c,&nbsp;d,&nbsp;e,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;g,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>)]
solve9th&nbsp;(t1,&nbsp;t2,&nbsp;t3,&nbsp;t4,&nbsp;t5,&nbsp;t6,&nbsp;t7,&nbsp;t8,&nbsp;t9)&nbsp;=&nbsp;<span style="color:blue;">do</span>
&nbsp;&nbsp;match&nbsp;&lt;-&nbsp;<span style="color:blue;">filter</span>&nbsp;(tile9Matches&nbsp;t6&nbsp;t8)&nbsp;$&nbsp;rotations&nbsp;t9
&nbsp;&nbsp;<span style="color:blue;">return</span>&nbsp;(t1,&nbsp;t2,&nbsp;t3,&nbsp;t4,&nbsp;t5,&nbsp;t6,&nbsp;t7,&nbsp;t8,&nbsp;match)</pre>
    </p>
    <p>
        Recalling that Haskell functions compose from right to left, the function starts by enumerating the four <code>rotations</code> of the ninth and final tile <code>t9</code>. It then filters those four rotations by the <code>tile9Matches</code> predicate.
    </p>
    <p>
        The <code>match</code> value is a rotation of <code>t9</code> that matches <code>t6</code> and <code>t8</code>. Whenever <code>solve9th</code> finds such a match, it returns the entire nine-tuple, because the assumption is that the eight first tiles are already valid.
    </p>
    <p>
        Notice that the function uses <code>do</code> notation in the list monad, so it's quite possible that the first <code>filter</code> expression produces no <code>match</code>. In that case, the second line of code never runs, and instead, the function returns the empty list.
    </p>
    <p>
        How do we find a tuple where the first eight elements are valid? Well, if we have seven valid tiles, we may consider the eighth and subsequently call <code>solve9th</code>:
    </p>
    <p>
        <pre><span style="color:#2b91af;">solve8th</span>&nbsp;<span style="color:blue;">::</span>&nbsp;&nbsp;(a,&nbsp;b,&nbsp;c,&nbsp;d,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;[(a,&nbsp;b,&nbsp;c,&nbsp;d,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>)]
solve8th&nbsp;(t1,&nbsp;t2,&nbsp;t3,&nbsp;t4,&nbsp;t5,&nbsp;t6,&nbsp;t7,&nbsp;t8,&nbsp;t9)&nbsp;=&nbsp;<span style="color:blue;">do</span>
&nbsp;&nbsp;match&nbsp;&lt;-&nbsp;<span style="color:blue;">filter</span>&nbsp;(tile8Matches&nbsp;t5&nbsp;t7)&nbsp;$&nbsp;rotations&nbsp;t8
&nbsp;&nbsp;solve9th&nbsp;(t1,&nbsp;t2,&nbsp;t3,&nbsp;t4,&nbsp;t5,&nbsp;t6,&nbsp;t7,&nbsp;match,&nbsp;t9)</pre>
    </p>
    <p>
        This function looks a lot like <code>solve9th</code>, but it instead enumerates the four <code>rotations</code> of the eighth tile <code>t8</code> and filters with the <code>tile8Matches</code> predicate. Due to the <code>do</code> notation, it'll only call <code>solve9th</code> if it finds a <code>match</code>.
    </p>
    <p>
        Once more, this function assumes that the first seven tiles are already in a legal constellation. How do we find seven valid tiles? The same way we find eight: By assuming that we have six valid tiles, and then finding the seventh, and so on:
    </p>
    <p>
        <pre><span style="color:#2b91af;">solve7th</span>&nbsp;<span style="color:blue;">::</span>&nbsp;&nbsp;(a,&nbsp;b,&nbsp;c,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;[(a,&nbsp;b,&nbsp;c,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>)]
solve7th&nbsp;(t1,&nbsp;t2,&nbsp;t3,&nbsp;t4,&nbsp;t5,&nbsp;t6,&nbsp;t7,&nbsp;t8,&nbsp;t9)&nbsp;=&nbsp;<span style="color:blue;">do</span>
&nbsp;&nbsp;match&nbsp;&lt;-&nbsp;<span style="color:blue;">filter</span>&nbsp;(tile7Matches&nbsp;t4)&nbsp;$&nbsp;rotations&nbsp;t7
&nbsp;&nbsp;solve8th&nbsp;(t1,&nbsp;t2,&nbsp;t3,&nbsp;t4,&nbsp;t5,&nbsp;t6,&nbsp;match,&nbsp;t8,&nbsp;t9)

<span style="color:#2b91af;">solve6th</span>&nbsp;<span style="color:blue;">::</span>&nbsp;&nbsp;(a,&nbsp;b,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;[(a,&nbsp;b,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>)]
solve6th&nbsp;(t1,&nbsp;t2,&nbsp;t3,&nbsp;t4,&nbsp;t5,&nbsp;t6,&nbsp;t7,&nbsp;t8,&nbsp;t9)&nbsp;=&nbsp;<span style="color:blue;">do</span>
&nbsp;&nbsp;match&nbsp;&lt;-&nbsp;<span style="color:blue;">filter</span>&nbsp;(tile6Matches&nbsp;t3&nbsp;t5)&nbsp;$&nbsp;rotations&nbsp;t6
&nbsp;&nbsp;solve7th&nbsp;(t1,&nbsp;t2,&nbsp;t3,&nbsp;t4,&nbsp;t5,&nbsp;match,&nbsp;t7,&nbsp;t8,&nbsp;t9)

<span style="color:#2b91af;">solve5th</span>&nbsp;<span style="color:blue;">::</span>&nbsp;&nbsp;(a,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;[(a,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>)]
solve5th&nbsp;(t1,&nbsp;t2,&nbsp;t3,&nbsp;t4,&nbsp;t5,&nbsp;t6,&nbsp;t7,&nbsp;t8,&nbsp;t9)&nbsp;=&nbsp;<span style="color:blue;">do</span>
&nbsp;&nbsp;match&nbsp;&lt;-&nbsp;<span style="color:blue;">filter</span>&nbsp;(tile5Matches&nbsp;t2&nbsp;t4)&nbsp;$&nbsp;rotations&nbsp;t5
&nbsp;&nbsp;solve6th&nbsp;(t1,&nbsp;t2,&nbsp;t3,&nbsp;t4,&nbsp;match,&nbsp;t6,&nbsp;t7,&nbsp;t8,&nbsp;t9)

<span style="color:#2b91af;">solve4th</span>&nbsp;<span style="color:blue;">::</span>&nbsp;&nbsp;(<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;[(<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>)]
solve4th&nbsp;(t1,&nbsp;t2,&nbsp;t3,&nbsp;t4,&nbsp;t5,&nbsp;t6,&nbsp;t7,&nbsp;t8,&nbsp;t9)&nbsp;=&nbsp;<span style="color:blue;">do</span>
&nbsp;&nbsp;match&nbsp;&lt;-&nbsp;<span style="color:blue;">filter</span>&nbsp;(tile4Matches&nbsp;t1)&nbsp;$&nbsp;rotations&nbsp;t4
&nbsp;&nbsp;solve5th&nbsp;(t1,&nbsp;t2,&nbsp;t3,&nbsp;match,&nbsp;t5,&nbsp;t6,&nbsp;t7,&nbsp;t8,&nbsp;t9)

<span style="color:#2b91af;">solve3rd</span>&nbsp;<span style="color:blue;">::</span>&nbsp;&nbsp;(<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;[(<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>)]
solve3rd&nbsp;(t1,&nbsp;t2,&nbsp;t3,&nbsp;t4,&nbsp;t5,&nbsp;t6,&nbsp;t7,&nbsp;t8,&nbsp;t9)&nbsp;=&nbsp;<span style="color:blue;">do</span>
&nbsp;&nbsp;match&nbsp;&lt;-&nbsp;<span style="color:blue;">filter</span>&nbsp;(tile3Matches&nbsp;t2)&nbsp;$&nbsp;rotations&nbsp;t3
&nbsp;&nbsp;solve4th&nbsp;(t1,&nbsp;t2,&nbsp;match,&nbsp;t4,&nbsp;t5,&nbsp;t6,&nbsp;t7,&nbsp;t8,&nbsp;t9)

<span style="color:#2b91af;">solve2nd</span>&nbsp;<span style="color:blue;">::</span>&nbsp;&nbsp;(<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;[(<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>)]
solve2nd&nbsp;(t1,&nbsp;t2,&nbsp;t3,&nbsp;t4,&nbsp;t5,&nbsp;t6,&nbsp;t7,&nbsp;t8,&nbsp;t9)&nbsp;=&nbsp;<span style="color:blue;">do</span>
&nbsp;&nbsp;match&nbsp;&lt;-&nbsp;<span style="color:blue;">filter</span>&nbsp;(tile2Matches&nbsp;t1)&nbsp;$&nbsp;rotations&nbsp;t2
&nbsp;&nbsp;solve3rd&nbsp;(t1,&nbsp;match,&nbsp;t3,&nbsp;t4,&nbsp;t5,&nbsp;t6,&nbsp;t7,&nbsp;t8,&nbsp;t9)</pre>
    </p>
    <p>
        You'll observe that <code>solve7th</code> down to <code>solve2nd</code> are very similar. The only things that really vary are the predicates, and the positions of the tile being examined, as well as its neighbours. Clearly I can generalize this code, but I'm not sure it's worth it. I wrote a few of these in the order I've presented them here, because it helped me think the problem through, and to be honest, once I had two or three of them, <a href="https://github.com/features/copilot">GitHub Copilot</a> picked up on the pattern and wrote the remaining functions for me.
    </p>
    <p>
        Granted, <a href="/2018/09/17/typing-is-not-a-programming-bottleneck">typing isn't a programming bottleneck</a>, so we should rather ask if this kind of duplication looks like a maintenance problem. Given that this is a one-time exercise, I'll just leave it be and move on.
    </p>
    <p>
        Particularly, if you're struggling to understand how this implements the 'truncated search tree', keep in mind that e..g <code>solve5th</code> is likely to produce no valid <code>match</code>, in which case it'll never call <code>solve6th</code>. The same may happen in <code>solve6th</code>, etc.
    </p>
    <p>
        The 'top' function is a bit different because it doesn't need to <code>filter</code> anything:
    </p>
    <p>
        <pre><span style="color:#2b91af;">solve1st</span>&nbsp;<span style="color:blue;">::</span>&nbsp;&nbsp;(<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span style="color:blue;">-&gt;</span>&nbsp;[(<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>)]
solve1st&nbsp;(t1,&nbsp;t2,&nbsp;t3,&nbsp;t4,&nbsp;t5,&nbsp;t6,&nbsp;t7,&nbsp;t8,&nbsp;t9)&nbsp;=&nbsp;<span style="color:blue;">do</span>
&nbsp;&nbsp;match&nbsp;&lt;-&nbsp;rotations&nbsp;t1
&nbsp;&nbsp;solve2nd&nbsp;(match,&nbsp;t2,&nbsp;t3,&nbsp;t4,&nbsp;t5,&nbsp;t6,&nbsp;t7,&nbsp;t8,&nbsp;t9)</pre>
    </p>
    <p>
        In the first position, any tile in any rotation is legal, so <code>solve1st</code> only enumerates all four <code>rotations</code> of <code>t1</code> and calls <code>solve2nd</code> for each.
    </p>
    <p>
        The final step is to compose <code>allPermutations</code> with <code>solve1st</code>:
    </p>
    <p>
        <pre><span style="color:#2b91af;">solutions</span>&nbsp;<span style="color:blue;">::</span>&nbsp;[(<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>,&nbsp;<span style="color:blue;">Tile</span>)]
solutions&nbsp;=&nbsp;allPermutations&nbsp;&gt;&gt;=&nbsp;solve1st</pre>
    </p>
    <p>
        Running this in GHCi on my 4½-year old laptop produces all 16 solutions in approximately 22 seconds.
    </p>
    <h3 id="d3d8c77398334534b5a200a240d7bddc">
        Evaluation <a href="#d3d8c77398334534b5a200a240d7bddc">#</a>
    </h3>
    <p>
        Is that good performance? Well, it turns out that it's possible to substantially improve on the situation. As I've mentioned a couple of times, so far I've been running the program from GHCi, the Haskell <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a>. Most of the 22 seconds are spent interpreting or compiling the code.
    </p>
    <p>
        If I compile the code with some optimizations turned on, the executable runs in approximately 300 ms. That seems quite decent, if I may say so.
    </p>
    <p>
        I can think of a few tweaks to the code that might conceivably improve things even more, but when I test, there's no discernable difference. Thus, I'll keep the code as shown here.
    </p>
    <p>
        Here's one of the solutions:
    </p>
    <p>
        <img src="/content/binary/hunde-spiel-solution.jpg" alt="One of the game solutions.">
    </p>
    <p>
        The information on the box claims that there's two solutions. Why does the code shown here produce 16 solutions?
    </p>
    <p>
        There's a good explanation for that. Recall that two of the tiles are identical. In the above solution picture, it's tile 1 and 3, although they're rotated 90° in relation to each other. This implies that you could take tile 1, rotate it counter-clockwise and put it in position 3, while simultaneously taking tile 3, rotating it clockwise, and putting it in position 1. Visually, you can't tell the difference, so they don't count as two distinct solutions. The algorithm, however, doesn't make that distinction, so it enumerates what is effectively the same solution twice.
    </p>
    <p>
        Not surprising, it turns out that all 16 solutions are doublets in that way. We can confirm that by evaluating <code>length $ <a href="https://hackage.haskell.org/package/base/docs/Data-List.html#v:nub">nub</a> solutions</code>, which returns <code>8</code>.
    </p>
    <p>
        Eight solutions are, however, still four times more than two. Can you figure out what's going on?
    </p>
    <p>
        The algorithm also enumerates four rotations of each solution. Once we take this into account, there's only two visually distinct solutions left. One of them is shown above. I also have a picture of the other one, but I'm not going to totally spoil things for you.
    </p>
    <h3 id="f97500846a6e481ebe1706278f324979">
        Conclusion <a href="#f97500846a6e481ebe1706278f324979">#</a>
    </h3>
    <p>
        When I was eight, I might have had the time and the patience to actually lay the puzzle. Despite the incredibly bad odds, I vaguely remember finally solving it. There must be some more holistic processing going on in the brain, if even a kid can solve the puzzle, because it seems inconceivable that it should be done as described here.
    </p>
    <p>
        Today, I don't care for that kind of puzzle in analog form, but I did, on the other hand, find it an interesting programming exercise.
    </p>
    <p>
        The code could be smaller, but I like it as it is. While a bit on the verbose side, I think that it communicates well what's going on.
    </p>
    <p>
        I was pleasantly surprised that I managed to get execution time down to 300 ms. I'd honestly not expected that when I started.
    </p>
</div>
<div id="comments">
    <hr>
    <h2 id="comments-header">
        Comments
    </h2>
    <div class="comment" id="fa087e5b49ce4a58936ac782cc44561b">
        <div class="comment-author"><a href="https://github.com/anka-213">Andreas Källberg</a> <a href="#fa087e5b49ce4a58936ac782cc44561b">#</a></div>
        <div class="comment-content">
            <p>
                Thanks for a nice blog post! I found the challange interesting, so I have written my own version of the code that both tries to be faster and also remove the redundant solutions, so it only generates two solutions in total. The code is available <a href="https://github.com/anka-213/haskell_toy_experiments/blob/master/HundeSpiel.hs">here</a>. It executes in roughly 8 milliseconds both in ghci and compiled (and takes a second to compile and run using runghc) on my laptop.
            </p>
            <p>
                In order to improve the performance, I start with a blank grid and one-by-one add tiles until it is no longer possible to do so, and then bactrack, kind of like how you would do it by hand. As a tiny bonus, that I haven't actually measured if it makes any practical difference, I also selected the order of filling in the grid so that they can constrain each other as much as possible, by filling 2-by-2 squares as early as possible. I have however calculated the number of boards explored in each of the two variations. With a spiral order, 6852 boards are explored, while with a linear order, 9332 boards are explored.
            </p>
            <p>
                In order to eliminate rotational symmetry, I start by filling the center square and fixing its rotation, rather than trying all rotations for it, since we could view any initial rotation of the center square as equivalent to rotating the whole board. In order to eliminate the identical solutions from the two identical tiles, I changed the encoding to use a number next to the tile to say how many copies are left of it, so when we choose a tile, there is only a single way to choose each tile, even if there are multiple copies of it. Both of these would also in theory make the code slightly faster if the time wasn't already dominated by general IO and other unrelated things.
            </p>
            <p>
                I also added various pretty printing and tracing utilites to the code, so you can see exactly how it executes and which partial solutions it explores.
            </p>
        </div>
        <div class="comment-date">2024-10-16 00:32 UTC</div>
    </div>
</div>
