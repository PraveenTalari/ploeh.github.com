---
layout: post
title: "Pendulum swings"
description: "The software development industry goes back and forth on how to do things, and so do I."
date: 2021-02-22 8:04 UTC
tags: [Software Design, Article Series]
image: "/content/binary/sine-wave.png"
image_alt: "A sine wave."
---
{% include JB/setup %}

<div id="post">
	<p>
		<em>{{ page.description }}</em>
	</p>
	<p>
		I've been working with something IT-related since 1994, and I've been a professional programmer since 1999. When you observe the software development industry over decades, you may start to notice some trends. One decade, service-oriented architecture (SOA) is cool; the next, consolidation sets in; then it's micro-services; and, as far as I can tell, monoliths are on the way in again, although I'm sure that we'll find something else to call them.
	</p>
	<p>
		It's as if a pendulum swings from one extreme to the other. Sooner or later, it comes back, only to then continue its swing in the other direction. If you view it over time and assume no loss to friction, a pendulum describes a sine wave.
	</p>
	<p>
		<img src="/content/binary/sine-wave.png" alt="A sine wave.">
	</p>
	<p>
		There's probably several reasons for this motion. The benign interpretation is that it's still a young industry and we're still learning. It's not uncommon to see oscillations in dynamic systems, particularly when feedback isn't immediate.
	</p>
	<p>
		Software architecture tends to produce slow feedback. Architecture solves more than one problem, including scalability, but a major motivation to think about architecture is to pick a way to organise the source code so that you don't have to rewrite from scratch every 2-3 years. Tautologically, then, it takes years before you know whether or not you succeeded.
	</p>
	<p>
		While waiting for feedback, you may continue doing what you believe is right: micro-services versus monoliths, unit tests versus acceptance tests, etcetera. Once you discover that a particular way to work has problems, you may overcompensate by going too far in the other direction.
	</p>
	<p>
		Once you discover the problem with that, you may begin to pull back towards the original position. Because feedback is delayed, the pendulum once more swings too far.
	</p>
	<p>
		If we manage to learn from our mistakes, one could hope that the oscillations we currently observe will dampen until we reach equilibrium in the future. The industry is still so young, though, that the pendulum makes wide swings. Perhaps it'll takes decades, or even centuries, before the oscillations die down.
	</p>
	<p>
		The more cynic interpretation is that most software developers have only a few years of professional experience, and aren't taught the experiences of past generations.
		<blockquote>
			<p>
				"Those who cannot remember the past are condemned to repeat it."
			</p>
			<footer><cite>George Santayana</cite></footer>
		</blockquote>
		In this light, the industry keeps regurgitating the same ideas over and over, never learning from past mistakes.
	</p>
	<p>
		The truth is probably a mix of both explanations.
	</p>
	<h3 id="36d029a90bfa4d35a7e8fc10048b8bcc">
		Personal pendulum <a href="#36d029a90bfa4d35a7e8fc10048b8bcc" title="permalink">#</a>
	</h3>
	<p>
		I've noticed a similar tendency in myself. I work in a particular way until I run into the limitations of that way. Then, after a time of frustration, I change direction.
	</p>
	<p>
		As an example, I'm an autodidact programmer. In the beginning of my career, I'd just throw together code until I thought it worked, then launch the software with the debugger attached only to discover that it didn't, then go back and tweak some more, and so on.
	</p>
	<p>
		Then I discovered test-driven development (TDD) and for years, it was the only way I could conceive of working. As my experience with TDD grew, I started to notice that it wasn't the panacea that I believed when it was all new. <a href="/2010/12/22/TheTDDApostate">I wrote about that as early as late 2010</a>. Knowing myself, I'd probably started to notice problems with TDD before that. I have cognitive biases just like the next person. You can lie to yourself for years before the problems become so blatant that you can no longer ignore them.
	</p>
	<p>
		To be clear, I never lost faith in TDD, but I began to glimpse the contours of its limitations. It's good for many circumstances, and it's still my preferred technique for developing new production code, but I use other techniques for e.g. prototyping.
	</p>
	<p>
		In 2020 I wrote a code base of middling complexity, and I noticed that I'd started to change my position on some other long-standing practices. As I've tried to explain, it may look like pendulum swings, but I hope that they are, at least, dampened swings. I intend to observe what happens so that I can learn from these new directions.
	</p>
	<p>
		In the following, I'll be writing about these new approaches that I'm trying on, and so far like:
		<ul>
			<li><a href="/2021/03/01/pendulum-swing-internal-by-default">Pendulum swing: internal by default</a></li>
			<li><a href="/2021/03/08/pendulum-swing-sealed-by-default">Pendulum swing: sealed by default</a></li>
			<li><a href="/2021/03/15/pendulum-swing-pure-by-default">Pendulum swing: pure by default</a></li>
			<li>Pendulum swing: no Haskell type annotation by default</li>
		</ul>
		I'd be naive if I believed these to be my final words on any of these topics. I'm currently trying them out for size; in a few decades I'll know more about how it all turns out.
	</p>
	<h3 id="fdb1ddeb6709428ca1f0e7f441085b3d">
		Conclusion <a href="#fdb1ddeb6709428ca1f0e7f441085b3d" title="permalink">#</a>
	</h3>
	<p>
		One year TDD is all the rage; a few years later, it's BDD. One year it's SOA, then it's <a href="https://alistair.cockburn.us/hexagonal-architecture/">ports and adapters</a> (which implies consolidated deployment), then it's micro-services. One year, it's XML, then it's JSON, then it's YAML. One decade it's structured programming, then it's object-orientation, then it's functional programming, and so on ad nauseam.
	</p>
	<p>
		Hopefully, this is just a symptom of growing pains. Hopefully, we'll learn from all these wild swings so that we don't have to rewrite applications when older developers leave.
	</p>
	<p>
		The only course of action that I can see for myself here is to document how I work so that I, and others, can learn from those experiences.
	</p>
	<p>
		<strong>Next:</strong> <a href="/2021/03/01/pendulum-swing-internal-by-default">Pendulum swing: internal by default</a>.
	</p>
</div>